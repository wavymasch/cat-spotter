<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cat Spotter Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { position: absolute; inset: 0; }
    .control {
      position: absolute; top: 12px; left: 12px; z-index: 1000;
      background: #ffffffee; backdrop-filter: blur(6px);
      padding: 12px; border-radius: 14px; box-shadow: 0 6px 20px rgba(0,0,0,.15);
      display: grid; gap: 8px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .control h1 { font-size: 16px; margin: 0 0 6px; }
    .control .row { display: flex; gap: 8px; flex-wrap: wrap; }
    button, input[type="file"]::file-selector-button {
      border: 0; border-radius: 10px; padding: 8px 10px; cursor: pointer;
      background: #111; color: #fff; font-weight: 600;
    }
    button.secondary { background: #f2f2f2; color: #111; }
    button.toggled { outline: 2px solid #111; }
    .legend { position: absolute; bottom: 12px; left: 12px; z-index: 1000;
      background: #ffffffee; padding: 10px; border-radius: 10px; box-shadow: 0 6px 20px rgba(0,0,0,.15);
      font-size: 12px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .legend .scale { display: flex; height: 10px; width: 160px; border-radius: 6px; overflow: hidden; margin-top: 6px; }
    .legend .scale > i { flex: 1; }
    .count { font-weight: 700; }
    .notice { font-size: 12px; color: #444; }
    .file { font-size: 12px; }
  </style>
</head>
<body>
  <div id="map" aria-label="Map of cat sightings"></div>

  <div class="control" role="region" aria-label="Controls">
    <h1>üêæ Cat Spotter</h1>
    <div class="row">
      <button id="addBtn" title="Click, then tap the map to add a sighting">Add sighting</button>
      <button id="stopBtn" class="secondary" title="Stop placing points">Stop adding</button>
      <button id="exportBtn" class="secondary" title="Download all sightings as JSON">Export JSON</button>
      <label class="file">
        <input id="importInput" type="file" accept="application/json" style="display:none;">
        <span id="importProxy" role="button" tabindex="0">Import JSON‚Ä¶</span>
      </label>
      <button id="clearBtn" class="secondary" title="Remove all data (local only)">Clear</button>
    </div>
    <div class="row">
      <button id="pointsToggle" class="secondary toggled">Points</button>
      <button id="heatToggle" class="secondary toggled">Heat (kernel)</button>
      <button id="gridToggle" class="secondary toggled">Heat (500√ó500 m grid)</button>
    </div>
    <div class="row notice">
      <span>Total sightings: <span id="count" class="count">0</span></span>
    </div>
  </div>

  <div class="legend" aria-label="Grid heat legend">
    <div>Cells: cats per 500√ó500 m</div>
    <div class="scale" id="legendScale"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    // --- Map setup ---
    const map = L.map('map').setView([47.3769, 8.5417], 12); // Z√ºrich default
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // --- Remote config & State ---
    // If you set a Google Apps Script Web App URL here, data will be shared globally.
    // Leave empty to keep using local-only storage.
    const REMOTE_ENDPOINT = '';

    let sightings = loadSightings(); // Array of {lat, lng, ts}
    let syncing = false;

    async function syncFromRemote() {
      if(!REMOTE_ENDPOINT) return; // skip if not configured
      try {
        const res = await fetch(REMOTE_ENDPOINT, { method: 'GET' });
        const json = await res.json();
        if(json && Array.isArray(json.data)){
          sightings = json.data
            .filter(p => typeof p.lat==='number' && typeof p.lng==='number')
            .map(p => ({ lat: p.lat, lng: p.lng, ts: p.ts || Date.now() }));
          saveSightings();
          refresh();
        }
      } catch (e) { console.warn('Remote sync failed', e); }
    }

    async function postSightingRemote(pt){
      if(!REMOTE_ENDPOINT) return;
      try {
        await fetch(REMOTE_ENDPOINT, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(pt)
        });
      } catch(e){ console.warn('Remote post failed', e); }
    }

    const markers = L.layerGroup().addTo(map);
    const heatLayer = L.heatLayer([], { radius: 22, blur: 18, minOpacity: 0.25 });
    const gridLayer = L.geoJSON(null, { style: feature => gridStyle(feature) });

    const layers = {
      points: markers,
      heat: heatLayer,
      grid: gridLayer
    };

    // --- UI elements ---
    const addBtn = document.getElementById('addBtn');
    const stopBtn = document.getElementById('stopBtn');
    const exportBtn = document.getElementById('exportBtn');
    const importInput = document.getElementById('importInput');
    const importProxy = document.getElementById('importProxy');
    const clearBtn = document.getElementById('clearBtn');
    const countEl = document.getElementById('count');
    const pointsToggle = document.getElementById('pointsToggle');
    const heatToggle = document.getElementById('heatToggle');
    const gridToggle = document.getElementById('gridToggle');

    let adding = false;

    function refresh() {
      countEl.textContent = sightings.length;
      drawMarkers();
      drawHeat();
      drawGrid();
      saveSightings();
    }

    function drawMarkers() {
      markers.clearLayers();
      sightings.forEach(pt => L.circleMarker([pt.lat, pt.lng], {
        radius: 6, weight: 1.5, color: '#111', fillColor: '#fff', fillOpacity: 0.9
      }).bindTooltip(new Date(pt.ts).toLocaleString()).addTo(markers));
    }

    function drawHeat() {
      const heatPoints = sightings.map(pt => [pt.lat, pt.lng, 1.0]);
      heatLayer.setLatLngs(heatPoints);
    }

    function drawGrid() {
      // Build a 0.5 km square grid over current bounds
      const b = map.getBounds();
      const bbox = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()];
      const cellSide = 0.5; // km
      const grid = turf.squareGrid(bbox, cellSide, { units: 'kilometers' });

      // points feature collection
      const pts = turf.featureCollection(
        sightings.map(pt => turf.point([pt.lng, pt.lat]))
      );

      // Count points in each cell
      grid.features.forEach(cell => {
        const within = turf.pointsWithinPolygon(pts, cell);
        cell.properties.count = within.features.length;
      });

      // Update layer
      gridLayer.clearLayers();
      gridLayer.addData(grid);
      updateLegend(grid);
    }

    function gridStyle(f) {
      const c = f.properties.count || 0;
      return {
        weight: 0.6,
        color: c > 0 ? '#333' : '#999',
        fillOpacity: c > 0 ? clamp(0.15 + c * 0.1, 0.15, 0.85) : 0.03,
        fillColor: colorRamp(c)
      };
    }

    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

    // Simple color ramp (light to intense). No external CSS needed.
    function colorRamp(count){
      const palette = ['#f1f8ff','#dbeafe','#bfdbfe','#93c5fd','#60a5fa','#3b82f6','#2563eb','#1d4ed8','#1e40af','#1e3a8a'];
      const idx = Math.max(0, Math.min(palette.length-1, count));
      return palette[idx];
    }

    function updateLegend(grid){
      const max = Math.max(0, ...grid.features.map(f => f.properties.count||0));
      const scale = document.getElementById('legendScale');
      scale.innerHTML = '';
      const steps = Math.max(5, Math.min(10, max+1));
      for(let i=0;i<steps;i++){
        const box = document.createElement('i');
        box.style.background = colorRamp(i);
        scale.appendChild(box);
      }
    }

    // --- Add mode ---
    addBtn.addEventListener('click', () => {
      adding = true; addBtn.classList.add('toggled');
    });
    stopBtn.addEventListener('click', () => {
      adding = false; addBtn.classList.remove('toggled');
    });

    map.on('click', async (e) => {
      if(!adding) return;
      const { lat, lng } = e.latlng;
      const pt = { lat, lng, ts: Date.now() };
      sightings.push(pt);
      refresh();
      postSightingRemote(pt);
    });
      refresh();
    });

    // --- Import / Export / Clear ---
    exportBtn.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(sightings, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'cat-sightings.json'; a.click();
      URL.revokeObjectURL(url);
    });

    importProxy.addEventListener('click', ()=> importInput.click());
    importProxy.addEventListener('keypress', (e)=>{ if(e.key==='Enter' || e.key===' '){ importInput.click(); }});

    importInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if(!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        if(Array.isArray(data)) {
          sightings = data.filter(p => typeof p.lat==='number' && typeof p.lng==='number')
                          .map(p => ({ lat: p.lat, lng: p.lng, ts: p.ts || Date.now() }));
          refresh();
        } else {
          alert('Invalid JSON format. Expected an array of {lat, lng, ts}');
        }
      } catch(err){
        alert('Import failed: ' + err.message);
      } finally {
        importInput.value = '';
      }
    });

    clearBtn.addEventListener('click', () => {
      if(confirm('Remove all locally stored sightings?')){
        sightings = []; refresh();
      }
    });

    // --- Layer toggles ---
    function toggle(btn, layer){
      const active = map.hasLayer(layer);
      if(active){ map.removeLayer(layer); btn.classList.remove('toggled'); }
      else { layer.addTo(map); btn.classList.add('toggled'); }
    }

    pointsToggle.addEventListener('click', () => toggle(pointsToggle, markers));
    heatToggle.addEventListener('click', () => toggle(heatToggle, heatLayer));
    gridToggle.addEventListener('click', () => toggle(gridToggle, gridLayer));

    // Recompute grid on move end (viewport defines bbox)
    map.on('moveend', drawGrid);

    // --- Persistence ---
    function saveSightings(){
      try { localStorage.setItem('cat_sightings', JSON.stringify(sightings)); } catch(e) {}
    }
    function loadSightings(){
      try { const raw = localStorage.getItem('cat_sightings'); return raw ? JSON.parse(raw) : []; } catch(e){ return []; }
    }

    // Init
    refresh();
    heatLayer.addTo(map);
    gridLayer.addTo(map);
    // Try to fetch shared data if endpoint is configured
    syncFromRemote();
  </script>
</body>
</html>
